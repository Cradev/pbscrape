<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>unsigned int hook_kbd = 0;
static unsigned int counter = 0;


int kbd_test_scan(unsigned short ass)
{

    if(ass=0)// se for 0 -&gt; c, else assembly
    {
    	int ipc_status;
    	  message msg;


    	kbd_subscribe_c();


    	unsigned long x;

    	    unsigned long f=0xE0;


    	    while (x != ESC_BREAK &amp;&amp; x != ESC_MAKE)
    	    {

    	        if ( (r = driver_receive(ANY, &amp;msg, &amp;ipc_status)) != 0 ) {
    	               printf("driver_receive failed with: %d", r);
    	               continue;
    	        }
    	        if (is_ipc_notify(ipc_status)) { /* received notification */
    	              switch (_ENDPOINT_P(msg.m_source)) {
    	                  case HARDWARE: /* hardware interrupt notification */
    	                      if (msg.NOTIFY_ARG &amp; ) { /* subscribed interrupt */
    	                          sys_inb(KBD_OUTBUF, &amp;x);

    	                          bool two_byte=false;

    	                          if(x==f)
    	                        	  two_byte=true;

    	                          if (x == ESC_BREAK || x == ESC_MAKE)
    	                          {
    	                              printf("\nEsc button was pressed.\n");
    	                              printf("Makecode: 0x01\nBreakcode: 0x81\n");
    	                              break;
    	                           }

    	                          if((x &amp; BIT(7)) == 0)
    	                          {
    	                        	  if(two_byte)
    	                        		  printf("\nMakecode : 0xE0%x\n",x);
    	                        	  else
    	                        		  printf("Makecode: 0x%x\n", x);
    	                          }
    	                          else
    	                          {
    	                        	  if(two_byte)
    	                        		  printf("Breakcode: 0xE0%x\n");
    	                        	  else
    	                        		  printf("Breakcode: 0x%x\n",x);
    	                          }
    	                        }
    	                      break;
    	                   default:
    	                   break; /* no other notifications expected: do nothing */
    	              }
    	        }
    	        else { /* received a standard message, not a notification */
    	            /* no standard messages expected: do nothing */
    	        }

    	    }

    	    kbd_unsubscribe_c();
    }
    else //assembly
    {
    	sys_iopenable()//........................................ver isto..........................
    	int ipc_status;
    	message msg;

    	kbd_subscribe_c();

    	while (x != ESC_BREAK &amp;&amp; x != ESC_MAKE)
    	    	    {

    	    	        if ( (r = driver_receive(ANY, &amp;msg, &amp;ipc_status)) != 0 ) {
    	    	               printf("driver_receive failed with: %d", r);
    	    	               continue;
    	    	        }
    	    	        if (is_ipc_notify(ipc_status)) { /* received notification */
    	    	              switch (_ENDPOINT_P(msg.m_source)) {
    	    	                  case HARDWARE: /* hardware interrupt notification */
    	    	                      if (msg.NOTIFY_ARG &amp; ) { /* subscribed interrupt */
    	    	                    	  static unsigned long x_asm;

    	    	                    	  x_asm= assembly_handler(x_asm);

    	    	                    	  if(x_asm == ESC_BREAK)
    	    	                    		  break;
    	    	                        }
    	    	                      break;
    	    	                   default:
    	    	                   break; /* no other notifications expected: do nothing */
    	    	              }
    	    	        }
    	    	        else { /* received a standard message, not a notification */
    	    	            /* no standard messages expected: do nothing */
    	    	        }

    	    	    }

    		kbd_unsubscribe_c();
    }




}


int kbd_subscribe_c()
{
    if (sys_irqsetpolicy(KBD_IRQ, IRQ_REENABLE || IRQ_EXCLUSIVE, &amp;hook_kbd) != OK) // trata do subscribe para o KBC
        return -1;

    if (sys_irqenable(&amp;hook_kbd) != OK)
        return -1;

    return 0;
}

int kbd_unsubscribe_c()
{
    if (sys_irqrmpolicy(&amp;hook_kbd) != OK) // trata do unsubscribe
        return -1;

    if (sys_irqdisable(&amp;hook_kbd) != OK)
        return -1;

    return 0;
}</p></body></html>
