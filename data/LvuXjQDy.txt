<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>// Set the element at position (i,j) to be the fill element.
  // Internally this should remove any node at that position by
  // unlinking it from row and column lists.  If no data exists at
  // (i,j), no changes are made to the matrix.  If (i,j) is out of
  // bounds, throw an IndexOutOfBoundsException with an appropriate
  // message.
  //
  // Target Complexity: O(E)
  //   E: number of non-fill elements in the matrix
  public void setToFill(int i, int j){
	  if(i &gt;= numRows || j &gt;= numCols){
		  throw new IndexOutOfBoundsException();
	  }
	  
	  Head<t> curRow = rows.get(i);
	  Head<t> curCol = cols.get(j); // the current column we are accessing
	  Node<t> curRowNode = curRow.nodes; // start at dummy node;
	  Node<t> curColNode = curCol.nodes; // start at dummy node of current Column
	  Node<t> prevRowNode = null;
	  Node<t> prevColNode = null;
	  
	  while(curRowNode != null){// while the current row node is not null
		  if(curRowNode.right == null || curRowNode.right.colHead.index &gt; j){
			  return;
		  }
		  else if(curRowNode.right.colHead.index == j){// if the next node is in the column we want
			  if(prevRowNode == null){
				  curRow.nodes.right = curRowNode.right.right; // change the links and set the node in the location
				  curRowNode.right.colHead = null;            // to null
				  curRowNode.right.rowHead = null;
				  curRowNode.right.right = null;
				  curRowNode.right.down = null;
			  }
			  else{
				  prevRowNode.right = curRowNode.right.right;
				  curRowNode.right.colHead = null;
				  curRowNode.right.rowHead = null;
				  curRowNode.right.right = null;
				  curRowNode.right.down = null;
			  }
			  numSet--;
		  }
		  else if(curRowNode.right.colHead.index &lt; j){
			  prevRowNode = curRowNode;
			  curRowNode = curRowNode.right;
		  }
	  }
	  //same thing as row but for column and opposite every variable
	  while(curColNode != null){ // while the current col node is not null
		  if(curColNode.down == null || curColNode.down.rowHead.index &gt; i ){ // if the next node is null return
			  return;
		  }
		  else if(curColNode.down.rowHead.index == i){
			  if(prevColNode == null){
				  curCol.nodes.down = curColNode.down.down;
				  curColNode.down.colHead = null;
				  curColNode.down.rowHead = null;
				  curColNode.down.right = null;
				  curColNode.down.down = null;
			  }
			  else{
				  prevColNode.down = curColNode.down.down;
				  curColNode.down.colHead = null;
				  curColNode.down.rowHead = null;
				  curColNode.down.right = null;
				  curColNode.down.down = null;
			  }
		  }
		  else if(curColNode.down.rowHead.index &lt; i){
			  prevColNode = curColNode;
			  curColNode = curColNode.down;
		  }
	  }
  }</t></t></t></t></t></t></p></body></html>
