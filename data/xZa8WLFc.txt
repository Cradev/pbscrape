<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>#include <iostream>
#include <cmath>

using namespace std;

double buildBinomialTree(double S0,double K, double r, double u, double d, 
                         double T, int N, char type, char style)
{
	int i,j;		//i : Timestep, j : Upward movements from time zero
	double p;		//Probability of up movement
	double S[200][200]={0};	//Asset price array
	double c[200][200]={0};	//Option price array
	double dt = T/N;	//Size of timestep
	double disc;		//Single period discount factor
	
	p = (exp(r*dt)-d)/(u-d);
	disc = exp(-r*dt);
	S[0][0] = S0;
	
	// Compute the stock price at each node
	for(i=0;i&lt;=N;i++)
	{
		for(j=0;j&lt;=i;j++)
		{
			S[i][j]=S0*(pow(u,j))*(pow(d,i-j));
			c[i][j]=0;
		}
	}
	
	
	// Compute the terminal payoffs
	for(j=0;j&lt;=N;j++){
		if(type == 'C')
			c[N][j]=max(S[N][j]-K,0.0);
		else
			c[N][j]=max(K-S[N][j],0.0);
	}
	
	
	// Work backwards through the tree
	for(i=N-1;i&gt;=0;i--)
	{
		for(j=i;j&gt;=0;j--)
		{
			c[i][j]=disc*((p)*(c[i+1][j+1])+(1-p)*(c[i+1][j]));
			
			if (style == 'A')
			{
				if(type == 'C')
				{
					c[i][j]=max(c[i][j],S[i][j]-K);
				}
				else
				{
					c[i][j]=max(c[i][j],K-S[i][j]);
				}
			}
		}
	}
	
	// Print the asset price tree
	cout &lt;<endl cout asset price tree for s endl print the option c return></endl></cmath></iostream></p></body></html>
