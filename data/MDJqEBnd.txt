<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>.data  
bufferresp: .space 102400
bufferresp2: .space 102400
buffernumero: .space 102400
buffersoma: .space 102400
fin: .asciiz "file.txt"      # filename for input
fin2: .asciiz "file2.txt"      # filename for input
buffer: .space 102400
buffer1: .asciiz "\n"
val : .space 102400
newline: .asciiz "\n"
.text
 
################################################ fileRead:
 
# Open file for reading
#USOS: t0 =so serve na leitura , t1 = contador da soma, t2 = endere&ccedil;o base buffer resposta,  t3 = load do numero , t4 = 0 para multx10, t5 = slt, t8 = resto, t9 = buffernumero
#Usos com s: s0 = armazena buffer da leitura, s1= armazena buffer dos bytes, s2=.lenght, s3 = contador da fila antes do enter, s4 = buffer da soma, s5 = somatemp,  $s6 = 48 (0 na tabela ASCII) e resto da div ,  s7=\n(valor 10)
#Usos com a: a1 = BUFFER RESPOSTA, a0, contador do numero de elementos da resposta, a2 = 45 (valor do negativo), a3 = contador do negativo

li   $v0, 13       # system call for open file
la   $a0, fin      # input file name
li   $a1, 0        # flag for reading
li   $a2, 0        # mode is ignored
syscall            # open a file
move $s0, $v0      # save the file descriptor
 
# reading from file just opened
 
li   $v0, 14       # system call for reading from file
move $a0, $s0      # file descriptor
la   $a1, buffer   # address of buffer from which to read
li   $a2,  40000  # hardcoded buffer length
syscall            # read from file

##### INICIALIZADORES #####

add $s2, $zero, $v0 #.length
#subi $s2, $s2, 1
addi $s7, $zero, 10 #tem 10
add $t1, $zero, $zero #inicializa contador para soma
la $s0, buffer
la $s1, buffernumero
la $s4, buffersoma
add $s3, $zero, $zero #Contador da fila
add $t4, $zero, $zero #0 at&eacute; o numero para multiplicar por 10
addi $s6, $zero, 48 #0 na tabela ASCII
add $s5, $zero, $zero
add $a0, $zero, $zero
add $a2, $zero, 45
add $a3, $zero, $zero
la $a1, bufferresp 
add $t6, $zero, $zero

##### INICIALIZADORES #####

Leitura:	#le byte por byte
lb $t0, 0($s0)
sb $t0, 0($s1)
beq $t0, $s7, AgrupandoNumeros1 #se contador for = \n (10)
addi $s0, $s0, 1 #incrementa para leitura do load
addi $s1, $s1, 1 #incrementa para dar store no buffernumero
addi $s3, $s3, 1 #incrementa o contador do numero na fila
subi $s2, $s2, 1 #tira do .lenght ########
bne $s2, $zero, Leitura
j AgrupandoNumeros
j FIM
#bne $t0, $s7, AgrupandoNumeros	#Quando t0 for 10, &eacute; um Enter

AgrupandoNumeros1: 
subi $s1, $s1, 1 #pega numero 2 (caso o exemplo seja 12)
AgrupandoNumeros:
subi $s1, $s1, 1
AgrupandoNumerosFinal:
lb $t3, 0($s1) #t3 vale 50 (2 em ASCII)
beq $t3, $a2, ComNegativo
LoopLinha:
slti $t5, $s3, 1 #se contador = 0, faz a soma da linha
bne $t5, $zero, Somadalinha
div $t3, $s6 #Dividindo um numero (por exemplo, 49 (1) da tabela ASCII por 0(48 na tabela ASCII) , ai o resto &eacute; 1
mfhi $t8 #t8 vai receber o resto da divisao
#mul $t5, $s7, $t4
bne $t4, $zero, SegundaIteracao #se for diferente de 0, entao ja ta na segunda casa decimal (10^1)
addi $t4, $t4, 1 #so faz essa soma se for 10^0
#addi $t3, $t3, 1
j Multiplica #migue para ir direto na multiplicacao
SegundaIteracao:
mul $t4, $t4, $s7 #faz a multiplicacao por 10
Multiplica:
mul $t8, $t8, $t4 #multiplicacao do valor pela casa decimal
subi $s3, $s3, 1 #tira um do contador da fila do numero
sw $t8, 0($s4)	 #armazena no vetor da soma
subi $s4, $s4, 4 #incrementa posicao do s4
addi $t1, $t1, 1 #incrementa o contador para soma 
j AgrupandoNumeros

ComNegativo:
addi $a3, $a3, 1
Somadalinha: #soma a linha inteira
addi $s4, $s4, 4
slti $t5, $t1, 1 #se i contador da soma for 0 
bne $t5, $zero, StoreMigue #faz o store num buffer
lw $t7, 0($s4) 
add $s5, $s5, $t7
subi $t1, $t1, 1
j Somadalinha

StoreMigue:
beq $a3, $zero, Store
StoreComNegativo:
mul $s5, $s5, -1
Store:
sw $s5, 0($a1) #da store num buffer definitivo
addi $a1, $a1, 4 #prox posicao do buffer resposta
addi $a0, $a1, 1
addi $t6, $t6, 1
add $a3, $zero, $zero
addi $s0, $s0, 1 #prox posicao do buffer de leitura
add $s3, $zero, $zero #zera o contador da linha
add $s1, $s1, 2 #avan&ccedil;a um espa&ccedil;o no buffer auxiliar
subi $s2, $s2, 1 #diminui o .length por causa do \n
add $s5, $zero, $zero
add $t4, $zero, $zero
slti $t5, $s2, 1
bne $t5, $zero, JumpFim
j Leitura
JumpFim:
j FIM
#subi $t6, $t6, 1

#j WhileMult10

# Close the file
FIM: 
#lw $t0, -4($a1)
#lw $t0, -8($a1)
#lw $t0, -12($a1)
#bne $a0, $zero, FIM
li   $v0, 16       # system call for close file
move $a0, $s6      # file descriptor to close
############################################################################################################
#Arquivo 2:

li   $v0, 13       # system call for open file
la   $a0, fin2      # input file name
li   $a1, 0        # flag for reading
li   $a2, 0        # mode is ignored
syscall            # open a file
move $s0, $v0      # save the file descriptor
 
# reading from file just opened
 
li   $v0, 14       # system call for reading from file
move $a0, $s0      # file descriptor
la   $a1, buffer   # address of buffer from which to read
li   $a2,  40000  # hardcoded buffer length
syscall            # read from file

##### INICIALIZADORES #####

add $s2, $zero, $v0 #.length
#subi $s2, $s2, 1
addi $s7, $zero, 10 #tem 10
add $t1, $zero, $zero #inicializa contador para soma
la $s0, buffer
la $s1, buffernumero
la $s4, buffersoma
add $s3, $zero, $zero #Contador da fila
add $t4, $zero, $zero #0 at&eacute; o numero para multiplicar por 10
addi $s6, $zero, 48 #0 na tabela ASCII
add $s5, $zero, $zero
add $a0, $zero, $zero
add $a2, $zero, 45
add $a3, $zero, $zero
la $a1, bufferresp2 
add $t9, $zero, $zero

##### INICIALIZADORES #####

Leitura2:	#le byte por byte
lb $t0, 0($s0)
sb $t0, 0($s1)
beq $t0, $s7, AgrupandoNumeros12 #se contador for = \n (10)
addi $s0, $s0, 1 #incrementa para leitura do load
addi $s1, $s1, 1 #incrementa para dar store no buffernumero
addi $s3, $s3, 1 #incrementa o contador do numero na fila
subi $s2, $s2, 1 #tira do .lenght ########
bne $s2, $zero, Leitura2
j AgrupandoNumeros2
j FIM2
#bne $t0, $s7, AgrupandoNumeros	#Quando t0 for 10, &eacute; um Enter

AgrupandoNumeros12: 
subi $s1, $s1, 1 #pega numero 2 (caso o exemplo seja 12)
AgrupandoNumeros2:
subi $s1, $s1, 1
AgrupandoNumerosFinal2:
lb $t3, 0($s1) #t3 vale 50 (2 em ASCII)
beq $t3, $a2, ComNegativo2
LoopLinha2:
slti $t5, $s3, 1 #se contador = 0, faz a soma da linha
bne $t5, $zero, Somadalinha2
div $t3, $s6 #Dividindo um numero (por exemplo, 49 (1) da tabela ASCII por 0(48 na tabela ASCII) , ai o resto &eacute; 1
mfhi $t8 #t8 vai receber o resto da divisao
#mul $t5, $s7, $t4
bne $t4, $zero, SegundaIteracao2 #se for diferente de 0, entao ja ta na segunda casa decimal (10^1)
addi $t4, $t4, 1 #so faz essa soma se for 10^0
#addi $t3, $t3, 1
j Multiplica2 #migue para ir direto na multiplicacao
SegundaIteracao2:
mul $t4, $t4, $s7 #faz a multiplicacao por 10
Multiplica2:
mul $t8, $t8, $t4 #multiplicacao do valor pela casa decimal
subi $s3, $s3, 1 #tira um do contador da fila do numero
sw $t8, 0($s4)	 #armazena no vetor da soma
subi $s4, $s4, 4 #incrementa posicao do s4
addi $t1, $t1, 1 #incrementa o contador para soma 
j AgrupandoNumeros2

ComNegativo2:
addi $a3, $a3, 1
Somadalinha2: #soma a linha inteira
addi $s4, $s4, 4
slti $t5, $t1, 1 #se i contador da soma for 0 
bne $t5, $zero, StoreMigue2 #faz o store num buffer
lw $t7, 0($s4) 
add $s5, $s5, $t7
subi $t1, $t1, 1
j Somadalinha2

StoreMigue2:
beq $a3, $zero, Store2
StoreComNegativo2:
mul $s5, $s5, -1
Store2:
sw $s5, 0($a1) #da store num buffer definitivo
addi $a1, $a1, 4 #prox posicao do buffer resposta
addi $a0, $a1, 1
addi $t9, $t9, 1
add $a3, $zero, $zero
addi $s0, $s0, 1 #prox posicao do buffer de leitura
add $s3, $zero, $zero #zera o contador da linha
add $s1, $s1, 2 #avan&ccedil;a um espa&ccedil;o no buffer auxiliar
subi $s2, $s2, 1 #diminui o .length por causa do \n
add $s5, $zero, $zero
add $t4, $zero, $zero
slti $t5, $s2, 1
bne $t5, $zero, JumpFim2
j Leitura2
JumpFim2:
j FIM2
#subi $t6, $t6, 1

#j WhileMult10

# Close the file
FIM2: 
la $a1, bufferresp
lw $t0, 0($a1)
lw $t1, 4($a1)
#bne $a0, $zero, FIM

li   $v0, 16       # system call for close file
move $a0, $s6      # file descriptor to close

################# LOGICA ##############################	

move $a0, $t6 #$a0 tamanho1
move $a2, $t9 #$a2 tamanho2
addi $s7, $zero, 0 #nulo = 0

la $a1, bufferresp
la $a3, bufferresp2
add $s0, $a0, $a2 #tamanho1 + tamanho2

CONCATENA:
	add $t0, $zero, $a0 #contador i = tamanho1
	addi $t1, $zero, 0 #contador j = 0
	
loop:	slt  $t2, $t0, $s0 #i &lt; (tamanho1 + tamanho2)?
	beq  $t2, $zero, fim_loop
	slt  $t2, $t1, $a2 #j &lt; (tamanho2)?
	beq  $t2, $zero, fim_loop
	
	sll  $s1, $t0, 2 # i*4 28
	add  $s1, $s1, $a1 #vetor[7] $t2
	lw   $t3, ($a1) #vetor[7*4] $t3
		
	sll  $t4, $t1, 2 # j*4
	add  $t4, $t4, $a3 #vetor2[0] $t2
	lw   $t5, ($t4) #vetor2[j] no $t5
	
	sw   $t5, ($s1)
	lw  $t6, ($s1)
	addi $t0, $t0, 1
	addi $t1, $t1, 1
	j loop	
fim_loop:
	#move $a1, $s1
	addi $s0, $t0, 0 
	
		lw $t1, 0($a1)
		lw $t2, 4($a1)
		lw $t3, 8($a1)
		lw $t4, 12($a1)
		lw $t5, 16($a1)
		lw $t1, 20($a1)
		lw $t2, 24($a1)
		lw $t3, 28($a1)
		lw $t4, 32($a1)
		lw $t5, 36($a1)
	
	
	
	
	jal ORDENA
	
	#jr $ra
	
ORDENA:
	addi $s1, $zero, 4
	addi $t1, $zero, 0 #i = 0
	#$t3 == aux
	loopi:
		slt $t4, $t1, $t0
		beq $t4, $zero, fim_ij
		
		mulo $t6, $t1, $s1 # i*4 no t6
		add $t7, $t6, $a1 #vetor3 no i = $t7
		lw  $t5, ($t7)
		addi $t2, $zero, 0 #j = 0
		loopj:
			slt $t4, $t2, $t0
			beq $t4, $zero, incrementai
						
			mulo $t4, $t2, $s1  # j*4 no t4
			add $t8, $t4, $a1 #vetor no j = $t8
			lw  $t6, ($t8)				
			
			slt $t9, $t5, $t6
			beq $t9, $zero, incrementaj
			addi $t3, $t6, 0 # aux = vetor3[j]
			
			sw $t5, ($t8) # vetor3[j] = vetor3[i]
			sw $t3, ($t7) # vetor3[i] = aux
			lw $t5, ($t7)
		
		incrementaj:
			addi $t2, $t2, 1			
			j loopj
		
		incrementai:
			addi $t1, $t1, 1
		
		j loopi		
		fim_ij:
		#move $a1, $t7
		
		
		lw $t1, 0($t7)
		lw $t2, -4($t7)
		lw $t3, -8($t7)
		lw $t4, -12($t7)
		lw $t5, -16($t7)
		lw $t1, -20($t7)
		lw $t2, -24($t7)
		lw $t3, -28($t7)
		lw $t4, -32($t7)
		lw $t5, -36($t7)
		
		
		
		jal TIRA_REPETIDOS
		#jr $ra ---&gt; nao sei se precisa	
		

		
TIRA_REPETIDOS:
	addi $t1, $zero, 1 #i = 1
	addi $s1, $zero, 4
	loop_rep:
		slt $t0, $t1, $s0
		beq $t0, $zero, fim_loop4
		
		mulo $t2, $t1, $s1 # i* -4
		add $t9, $t2, $a1 #vetor3[i] = $t3
		lw  $t4, ($t9)
				
		lw  $t5, 4($t9) #vetor3[i-1] = $t5
		
		bne $t4, $t5, incremento
		addi $t4, $zero, -456786490 #posicao sem chave
		sw $t4, ($t9)
		addi $s7, $s7, 1
incremento:	addi $t1, $t1, 1

		j loop_rep
		fim_loop4:
		
		move $a1, $t9
		lw $t1, 0($a1)
		lw $t2, -4($a1)
		lw $t3, -8($a1)
		lw $t4, -12($a1)
		lw $t5, -16($a1)
		lw $t1, -20($a1)
		lw $t2, -24($a1)
		lw $t3, -28($a1)
		lw $t4, -32($a1)
		lw $t5, -36($a1)
		
		
AJUSTE_FINAL:
	addi $t1, $zero, 0 #i = 0
	addi $t2, $zero, 0 #j = 0
	addi $s1, $zero, -4
	#
	# $s4 == vetor4
	loop5:
		slt $t3, $t1, $s0
		bne $t3, $zero, prox
		prox:
			sub $t4, $s0, $s7 #tam-nulo = $t4
			slt $t3, $t2, $t4
			beq $t3, $zero, fim_loop5
			addi $t5, $zero, -456786490 #posicao sem chave $t5
			
			mulo $t6, $t1, $s1
			add $t7, $t6, $a1 #vetor3[i] = $t
			lw  $t8, ($t7) #vetor3[i] = $t7
			
			mulo $t9, $t2, $s1
			add $t0, $t9, $a3 #vetor3[j] = $t
			lw  $t4, ($t0) #vetor3[j] = $t0
			
					
			beq $t8, $t5, incrementaa #vetor3[i] ==  -456786490
			lw $t4, ($t7)
			sw $t4, ($t0)
			addi $t2, $t2, 1
	incrementaa:	addi $t1, $t1, 1
			j loop5
			fim_loop5:	
			move $a1, $t0 #vetor3 no a0
			lw $t0, 0($a1)
			lw $t0, 4($a1)
			lw $t0, 8($a1)
			lw $t0, 12($a1)
			lw $t0, 16($a1)
			lw $t0, 20($a1)
			lw $t0, 24($a1)
			lw $t0, 28($a1)</p></body></html>
