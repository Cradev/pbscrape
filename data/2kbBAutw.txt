<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>using System;

namespace Recognizer
{
    internal static class SobelFilterTask
    {
        /* 
		&#1056;&#1072;&#1079;&#1073;&#1077;&#1088;&#1080;&#1090;&#1077;&#1089;&#1100;, &#1082;&#1072;&#1082; &#1088;&#1072;&#1073;&#1086;&#1090;&#1072;&#1077;&#1090; &#1085;&#1080;&#1078;&#1077;&#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1082;&#1086;&#1076; (&#1085;&#1072;&#1079;&#1099;&#1074;&#1072;&#1077;&#1084;&#1099;&#1081; &#1092;&#1080;&#1083;&#1100;&#1090;&#1088;&#1072;&#1094;&#1080;&#1077;&#1081; &#1057;&#1086;&#1073;&#1077;&#1083;&#1103;), 
		&#1080; &#1082;&#1072;&#1082;&#1086;&#1077; &#1086;&#1090;&#1085;&#1086;&#1096;&#1077;&#1085;&#1080;&#1077; &#1082; &#1085;&#1077;&#1084;&#1091; &#1080;&#1084;&#1077;&#1102;&#1090; &#1101;&#1090;&#1080; &#1084;&#1072;&#1090;&#1088;&#1080;&#1094;&#1099;:
		
		     | -1 -2 -1 |           | -1  0  1 |
		Sx = |  0  0  0 |      Sy = | -2  0  2 |
		     |  1  2  1 |           | -1  0  1 |
		
		https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D0%A1%D0%BE%D0%B1%D0%B5%D0%BB%D1%8F
		
		&#1055;&#1086;&#1087;&#1088;&#1086;&#1073;&#1091;&#1081;&#1090;&#1077; &#1079;&#1072;&#1084;&#1077;&#1085;&#1080;&#1090;&#1100; &#1092;&#1080;&#1083;&#1100;&#1090;&#1088; &#1057;&#1086;&#1073;&#1077;&#1083;&#1103; 3x3 &#1085;&#1072; &#1092;&#1080;&#1083;&#1100;&#1090;&#1088; &#1057;&#1086;&#1073;&#1077;&#1083;&#1103; 5x5 &#1080; &#1089;&#1088;&#1072;&#1074;&#1085;&#1080;&#1090;&#1077; &#1088;&#1077;&#1079;&#1091;&#1083;&#1100;&#1090;&#1072;&#1090;&#1099;. 
		http://www.cim.mcgill.ca/~image529/TA529/Image529_99/assignments/edge_detection/references/sobel.htm

		&#1054;&#1073;&#1086;&#1073;&#1097;&#1080;&#1090;&#1077; &#1082;&#1086;&#1076; &#1087;&#1088;&#1080;&#1084;&#1077;&#1085;&#1077;&#1085;&#1080;&#1103; &#1092;&#1080;&#1083;&#1100;&#1090;&#1088;&#1072; &#1090;&#1072;&#1082;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1084;&#1086;&#1078;&#1085;&#1086; &#1073;&#1099;&#1083;&#1086; &#1087;&#1077;&#1088;&#1077;&#1076;&#1072;&#1074;&#1072;&#1090;&#1100; &#1077;&#1084;&#1091; &#1083;&#1102;&#1073;&#1099;&#1077; &#1084;&#1072;&#1090;&#1088;&#1080;&#1094;&#1099;, &#1083;&#1102;&#1073;&#1086;&#1075;&#1086; &#1085;&#1077;&#1095;&#1077;&#1090;&#1085;&#1086;&#1075;&#1086; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1072;.
		&#1060;&#1080;&#1083;&#1100;&#1090;&#1088;&#1099; &#1057;&#1086;&#1073;&#1077;&#1083;&#1103; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1086;&#1074; 3 &#1080; 5 &#1076;&#1086;&#1083;&#1078;&#1085;&#1099; &#1073;&#1099;&#1090;&#1100; &#1095;&#1072;&#1089;&#1090;&#1085;&#1099;&#1084; &#1089;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084;. 
		&#1055;&#1086;&#1089;&#1083;&#1077; &#1090;&#1072;&#1082;&#1086;&#1075;&#1086; &#1086;&#1073;&#1086;&#1073;&#1097;&#1077;&#1085;&#1080;&#1103; &#1084;&#1077;&#1085;&#1103;&#1090;&#1100; &#1092;&#1080;&#1083;&#1100;&#1090;&#1088; &#1057;&#1086;&#1073;&#1077;&#1083;&#1103; &#1086;&#1076;&#1085;&#1086;&#1075;&#1086; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1072; &#1085;&#1072; &#1076;&#1088;&#1091;&#1075;&#1086;&#1081; &#1073;&#1091;&#1076;&#1077;&#1090; &#1083;&#1077;&#1075;&#1082;&#1086;.
		*/

        public static double[,] SobelFilter(double[,] g, double[,] sx)
        {
            var width = g.GetLength(0);
            var height = g.GetLength(1);
            var result = new double[width, height];
            sx = new double[5, 5] { 
                { 1, 4,   6,   4,   1},
                { 2,   8,  12,   8,   2},
                { 0,   0,   0,   0,   0},
                { -2,  -8, -12,  -8,  -2},
                { -1,  -4,  -6,  -4,  -1}
            };
            var sy = RotateMatrix(sx, sx.GetLength(0));
            int radiusOfMatrix = (sx.GetLength(0) - 1) / 2;
            int matrixSize = sx.GetLength(0);

            for (int y = radiusOfMatrix; y &lt; height - radiusOfMatrix; y++)
            {
                for (int x = radiusOfMatrix; x &lt; width - radiusOfMatrix; x++)
                {
                    double gx = 0;
                    double gy = 0;
                    double currentNum = 0;
                    for (int i = 0; i &lt; matrixSize; i++)
                        for (int j = 0; j &lt; matrixSize; j++)
                        {
                            currentNum = g[(x - radiusOfMatrix + i), (y - radiusOfMatrix + j)];
                            gx += sx[i,j] * currentNum;
                            gy += sy[i, j] * currentNum;
                        }
                    result[x, y] = Math.Sqrt(gx * gx + gy * gy);

                }
            }

            return result;
        }
        static double[,] RotateMatrix(double[,] matrix, int n)
        {
            double[,] ret = new double[n, n];

            for (int i = 0; i &lt; n; ++i)
            {
                for (int j = 0; j &lt; n; ++j)
                {
                    ret[i, j] = matrix[n - j - 1, i];
                }
            }

            return ret;
        }
    }
}</p></body></html>
