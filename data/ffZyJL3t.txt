<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>package control;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URL;
import java.util.LinkedList;
import java.util.Random;

import javax.swing.JOptionPane;

public class SnakeCanvas extends Canvas implements Runnable, KeyListener {

	private final int boxHeight = 15;
	private final int boxWidth = 15;
	private final int gridWidth = 25;
	private final int gridHeight = 25;
	
	private LinkedList<point> snake;
	private Point fruit;
	
	private Thread runThread;
	
	private int direction = Direction.noDirection;
	private int score;
	private String highScore = "";
	
	private Image menuImage = null;
	private boolean isInMenu = true;
	
	private boolean isAtEndGame = false;
	private boolean won = false;
	
	public void paint(Graphics g){
		
		if(runThread == null){
			this.setPreferredSize(new Dimension(640, 480));
			this.addKeyListener(this);
			runThread = new Thread(this);
			runThread.start();
		}
		
		if(isInMenu){
			drawMenu(g);
		}else if(isAtEndGame){
			drawEndGame(g);
		}
		else{
			if(snake == null){
				snake = new LinkedList<point>();
				GenerateDefaultSnake();		
				PlaceFruit();
			}
			
			if(highScore.equals("")){
				highScore = this.getHighScoreValue();
			}
			
			DrawFruit(g);
			DrawGrid(g);
			DrawSnake(g);
			DrawScore(g);
		}		
	}
	
	public void drawEndGame(Graphics g){
		BufferedImage endGameImage = new BufferedImage(this.getPreferredSize().width, this.getPreferredSize().height, BufferedImage.TYPE_INT_ARGB);
		Graphics endGameGraphics = endGameImage.getGraphics();
		
		if(won)
			endGameGraphics.drawString("You WON!", this.getPreferredSize().width/2, this.getPreferredSize().height/2);
		else
			endGameGraphics.drawString("You LOST!", this.getPreferredSize().width/2, this.getPreferredSize().height/2);
	
		endGameGraphics.drawString("Your score: " + this.score, this.getPreferredSize().width/2, (this.getPreferredSize().height/2)+10);
		endGameGraphics.drawString("Press \"space\" to start a new game!", this.getPreferredSize().width/2, (this.getPreferredSize().height/2)+40);
	
		g.drawImage(endGameImage, 0, 0, this);
	}
	
	public void drawMenu(Graphics g){
		if(this.menuImage==null){
			try{
				URL imagePath = SnakeCanvas.class.getClassLoader().getResource("snakeMenu.png");
				this.menuImage = Toolkit.getDefaultToolkit().getImage(imagePath);
			}catch(Exception e){
				e.printStackTrace();
			}
		}
		
		g.drawImage(menuImage, 0, 0, 640, 480, this);
	}
	
	public void update(Graphics g){
		Graphics offScreenGraphics;
		BufferedImage offscreen = null;
		
		Dimension d = this.getSize();
		
		offscreen = new BufferedImage(d.width, d.height, BufferedImage.TYPE_INT_ARGB);
		offScreenGraphics = offscreen.getGraphics();
		offScreenGraphics.setColor(this.getBackground());
		offScreenGraphics.fillRect(0, 0, d.width, d.height);
		offScreenGraphics.setColor(this.getForeground());
		paint(offScreenGraphics);
		
		g.drawImage(offscreen, 0, 0, this);
	}
	
	public void GenerateDefaultSnake(){
		score = 0;
		snake.clear();
		
		snake.add(new Point (0,2));
		snake.add(new Point (0,1));
		snake.add(new Point (0,0));
		direction = Direction.noDirection;
	}
	
	public void Move(){
		Point head = snake.peekFirst();
		Point newPoint = head;
		switch(direction){
			case Direction.north:
				newPoint = new Point(head.x, head.y - 1);
				break;
			case Direction.south:
				newPoint = new Point(head.x, head.y + 1);
				break;
			case Direction.west:
				newPoint = new Point(head.x - 1, head.y);
				break;
			case Direction.east:
				newPoint = new Point(head.x + 1, head.y);
				break;
		}
		
		snake.remove(snake.peekLast());
		
		if(newPoint.equals(fruit)){
			//a cobra encosta na fruta
			score+=10;
			
			Point addPoint = (Point) newPoint.clone();
			
			switch(direction){
			case Direction.north:
				newPoint = new Point(head.x, head.y - 1);
				break;
			case Direction.south:
				newPoint = new Point(head.x, head.y + 1);
				break;
			case Direction.west:
				newPoint = new Point(head.x - 1, head.y);
				break;
			case Direction.east:
				newPoint = new Point(head.x + 1, head.y);
				break;
			}
			snake.push(addPoint);
			PlaceFruit();
			
		}else if(newPoint.x&lt;0 || newPoint.x&gt;(gridWidth-1)){
			//encostou na borda lateral, reseta o jogo
			checkScore();
			won = false;
			isAtEndGame = true;
			return;
		}else if(newPoint.y&lt;0 || newPoint.y&gt;  (gridHeight-1)){
			//encostou na borda superior, reseta o jogo
			checkScore();
			won = false;
			isAtEndGame = true;
			return;
		}else if(snake.contains(newPoint)){
			//encostou na cobra, reseta o jogo
			if(direction != Direction.noDirection){
				checkScore();
				won = false;
				isAtEndGame = true;
				return;
			}
		}else if(snake.size() == (gridWidth * gridHeight)){
			//ganhar
			checkScore();
			won = true;
			isAtEndGame = true;
			return;
		}
		
		snake.push(newPoint);
	}
	
	public void DrawScore(Graphics g){
		g.setColor(Color.black);
		g.drawString("Score: " + score, 0, boxHeight * gridHeight + 12);
		g.drawString("Highscore: " + highScore, 0, boxHeight * gridHeight + 24);
	}
	
	public void checkScore(){
		if(highScore.equals(""))
			return;
		
		if(score &gt; Integer.parseInt(highScore.split(":")[1])){
			String name = JOptionPane.showInputDialog("You set a new highscore. What is your name?");
			highScore = name + ":" + score;
			
			File scoreFile = new File("highscore.dat");
			
			if (!scoreFile.exists()){
				try {
					scoreFile.createNewFile();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			FileWriter writeFile = null;
			BufferedWriter writer = null;
			try{
				writeFile = new FileWriter(scoreFile);
				writer = new BufferedWriter(writeFile);
				writer.write(this.highScore);
			}catch(Exception e){
				//errors
			}finally{
				if(writer != null){
					try {
						writer.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}
		}
	}
	
	public void DrawGrid(Graphics g){
		//desenhando o ret&acirc;ngulo de fora
		g.drawRect(0, 0, gridWidth * boxWidth, gridHeight * boxHeight);
		//desenhando as linhas verticais
		for(int x = boxWidth; x<gridwidth boxwidth x g.drawline boxheight gridheight as linhas horizontais for y="boxHeight;" gridwidth public void drawsnake g g.setcolor p : snake g.fillrect p.y drawfruit g.filloval fruit.y placefruit random rand="new" int randomx="rand.nextInt(gridWidth);" randomy="rand.nextInt(gridHeight);" point randompoint="new" while fruit="randomPoint;" run infinito para atualizar o jogo e calcular posi if move repaint try thread.currentthread thread.sleep score e.printstacktrace string gethighscorevalue filereader readfile="null;" bufferedreader reader="null;" return reader.readline reader.close keypressed switch case keyevent.vk_up: direction.south direction="Direction.north;" break keyevent.vk_down: direction.north keyevent.vk_right: direction.west keyevent.vk_left: direction.east keyevent.vk_enter: isinmenu="false;" keyevent.vk_escape: keyevent.vk_space: isatendgame="false;" won="false;" generatedefaultsnake keyreleased keytyped></gridwidth></point></point></p></body></html>
